<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Top-level API for Mithril Stake-based Threshold Multisignature scheme. See figure 6 of the paper for most of the protocol."><title>mithril_stm::stm - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="mithril_stm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.1 (eb26296b5 2023-08-03)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../mithril_stm/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../mithril_stm/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module stm</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">mithril_stm</a>::<wbr><a class="mod" href="#">stm</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/mithril_stm/stm.rs.html#1-1334">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Top-level API for Mithril Stake-based Threshold Multisignature scheme.
See figure 6 of <a href="https://eprint.iacr.org/2021/916">the paper</a> for most of the
protocol.</p>
<p>What follows is a simple example showing the usage of STM.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>blake2::{Blake2b, digest::consts::U32};
<span class="kw">use </span>mithril_stm::key_reg::KeyReg; <span class="comment">// Import key registration functionality
</span><span class="kw">use </span>mithril_stm::stm::{StmClerk, StmInitializer, StmParameters, StmSig, StmSigner};
<span class="kw">use </span>mithril_stm::AggregationError;
<span class="kw">use </span>rayon::prelude::<span class="kw-2">*</span>; <span class="comment">// We use par_iter to speed things up

</span><span class="kw">use </span>rand_chacha::ChaCha20Rng;
<span class="kw">use </span>rand_core::{RngCore, SeedableRng};

<span class="kw">let </span>nparties = <span class="number">4</span>; <span class="comment">// Use a small number of parties for this example
</span><span class="kw">type </span>D = Blake2b&lt;U32&gt;; <span class="comment">// Setting the hash function for convenience

</span><span class="kw">let </span><span class="kw-2">mut </span>rng = ChaCha20Rng::from_seed([<span class="number">0u8</span>; <span class="number">32</span>]); <span class="comment">// create and initialize rng
</span><span class="kw">let </span><span class="kw-2">mut </span>msg = [<span class="number">0u8</span>; <span class="number">16</span>]; <span class="comment">// setting an arbitrary message
</span>rng.fill_bytes(<span class="kw-2">&amp;mut </span>msg);

<span class="comment">// In the following, we will have 4 parties try to sign `msg`, then aggregate and
// verify those signatures.

//////////////////////////
// initialization phase //
//////////////////////////

// Set low parameters for testing
// XXX: not for production
</span><span class="kw">let </span>params = StmParameters {
    m: <span class="number">100</span>, <span class="comment">// Security parameter XXX: not for production
    </span>k: <span class="number">2</span>, <span class="comment">// Quorum parameter XXX: not for production
    </span>phi_f: <span class="number">0.2</span>, <span class="comment">// Lottery parameter XXX: not for production
</span>};

<span class="comment">// Generate some arbitrary stake for each party
// Stake is an integer.
// Total stake of all parties is total stake in the system.
</span><span class="kw">let </span>stakes = (<span class="number">0</span>..nparties)
    .into_iter()
    .map(|<span class="kw">_</span>| <span class="number">1 </span>+ (rng.next_u64() % <span class="number">9999</span>))
    .collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;();

<span class="comment">// Create a new key registry from the parties and their stake
</span><span class="kw">let </span><span class="kw-2">mut </span>key_reg = KeyReg::init();

<span class="comment">// For each party, crate a StmInitializer.
// This struct can create keys for the party.
</span><span class="kw">let </span><span class="kw-2">mut </span>ps: Vec&lt;StmInitializer&gt; = Vec::with_capacity(nparties);
<span class="kw">for </span>stake <span class="kw">in </span>stakes {
    <span class="comment">// Create keys for this party
    </span><span class="kw">let </span>p = StmInitializer::setup(params, stake, <span class="kw-2">&amp;mut </span>rng);
    <span class="comment">// Register keys with the KeyReg service
    </span>key_reg
        .register(p.stake, p.verification_key())
        .unwrap();
    ps.push(p);
}

<span class="comment">// Close the key registration.
</span><span class="kw">let </span>closed_reg = key_reg.close();

<span class="comment">// Finalize the StmInitializer and turn it into a StmSigner, which can execute the
// rest of the protocol.
</span><span class="kw">let </span>ps = ps
    .into_par_iter()
    .map(|p| p.new_signer(closed_reg.clone()).unwrap())
    .collect::&lt;Vec&lt;StmSigner&lt;D&gt;&gt;&gt;();

<span class="comment">/////////////////////
// operation phase //
/////////////////////

// Next, each party tries to sign the message for each index available.
// We collect the successful signatures into a vec.
</span><span class="kw">let </span>sigs = ps
    .par_iter()
    .filter_map(|p| {
        <span class="kw">return </span>p.sign(<span class="kw-2">&amp;</span>msg);
    })
    .collect::&lt;Vec&lt;StmSig&gt;&gt;();

<span class="comment">// StmClerk can aggregate and verify signatures.
</span><span class="kw">let </span>clerk = StmClerk::from_signer(<span class="kw-2">&amp;</span>ps[<span class="number">0</span>]);

<span class="comment">// Aggregate and verify the signatures
</span><span class="kw">let </span>msig = clerk.aggregate(<span class="kw-2">&amp;</span>sigs, <span class="kw-2">&amp;</span>msg);
<span class="kw">match </span>msig {
    <span class="prelude-val">Ok</span>(aggr) =&gt; {
        <span class="macro">println!</span>(<span class="string">&quot;Aggregate ok&quot;</span>);
        <span class="macro">assert!</span>(aggr
            .verify(<span class="kw-2">&amp;</span>msg, <span class="kw-2">&amp;</span>clerk.compute_avk(), <span class="kw-2">&amp;</span>params)
            .is_ok());
    }
    <span class="prelude-val">Err</span>(AggregationError::NotEnoughSignatures(n, k)) =&gt; {
        <span class="macro">println!</span>(<span class="string">&quot;Not enough signatures&quot;</span>);
        <span class="macro">assert!</span>(n &lt; params.k &amp;&amp; k == params.k)
    }
    <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; <span class="macro">unreachable!</span>(),
}</code></pre></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.StmAggrSig.html" title="struct mithril_stm::stm::StmAggrSig">StmAggrSig</a></div><div class="desc docblock-short"><code>StmMultiSig</code> uses the “concatenation” proving system (as described in Section 4.3 of the original paper.)
This means that the aggregated signature contains a vector with all individual signatures.
BatchPath is also a part of the aggregate signature which covers path for all signatures.</div></li><li><div class="item-name"><a class="struct" href="struct.StmAggrVerificationKey.html" title="struct mithril_stm::stm::StmAggrVerificationKey">StmAggrVerificationKey</a></div><div class="desc docblock-short">Stm aggregate key (batch compatible), which contains the merkle tree commitment and the total stake of the system.
Batch Compat Merkle tree commitment includes the number of leaves in the tree in order to obtain batch path.</div></li><li><div class="item-name"><a class="struct" href="struct.StmClerk.html" title="struct mithril_stm::stm::StmClerk">StmClerk</a></div><div class="desc docblock-short"><code>StmClerk</code> can verify and aggregate <code>StmSig</code>s and verify <code>StmMultiSig</code>s.
Clerks can only be generated with the registration closed.
This avoids that a Merkle Tree is computed before all parties have registered.</div></li><li><div class="item-name"><a class="struct" href="struct.StmInitializer.html" title="struct mithril_stm::stm::StmInitializer">StmInitializer</a></div><div class="desc docblock-short">Initializer for <code>StmSigner</code>.
This is the data that is used during the key registration procedure.
Once the latter is finished, this instance is consumed into an <code>StmSigner</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.StmParameters.html" title="struct mithril_stm::stm::StmParameters">StmParameters</a></div><div class="desc docblock-short">Used to set protocol parameters.</div></li><li><div class="item-name"><a class="struct" href="struct.StmSig.html" title="struct mithril_stm::stm::StmSig">StmSig</a></div><div class="desc docblock-short">Signature created by a single party who has won the lottery.</div></li><li><div class="item-name"><a class="struct" href="struct.StmSigner.html" title="struct mithril_stm::stm::StmSigner">StmSigner</a></div><div class="desc docblock-short">Participant in the protocol can sign messages.
This instance can only be generated out of an <code>StmInitializer</code> and a <code>ClosedKeyReg</code>.
This ensures that a <code>MerkleTree</code> root is not computed before all participants have registered.</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Index.html" title="type mithril_stm::stm::Index">Index</a></div><div class="desc docblock-short">Quorum index for signatures.
An aggregate signature (<code>StmMultiSig</code>) must have at least <code>k</code> unique indices.</div></li><li><div class="item-name"><a class="type" href="type.Stake.html" title="type mithril_stm::stm::Stake">Stake</a></div><div class="desc docblock-short">The quantity of stake held by a party, represented as a <code>u64</code>.</div></li><li><div class="item-name"><a class="type" href="type.StmVerificationKey.html" title="type mithril_stm::stm::StmVerificationKey">StmVerificationKey</a></div><div class="desc docblock-short">Wrapper of the MultiSignature Verification key</div></li><li><div class="item-name"><a class="type" href="type.StmVerificationKeyPoP.html" title="type mithril_stm::stm::StmVerificationKeyPoP">StmVerificationKeyPoP</a></div><div class="desc docblock-short">Wrapper of the MultiSignature Verification key with proof of possession</div></li></ul></section></div></main></body></html>